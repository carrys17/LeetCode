package com.example.shang;

import java.util.Arrays;
import java.util.HashMap;
import java.util.Map;

/**两个数之和
 * 给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。
 * 你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。
 * 
 * 例子：
 * 	给定 nums = [2, 7, 11, 15], target = 9
 *	因为 nums[0] + nums[1] = 2 + 7 = 9
 *	所以返回 [0, 1]
 * 
 * 思路，普通的就是遍历两次数组，第一次查找nums[i],第二次查找target-nums[i]，
 * 这样的时间复杂度为O(n*n)
 * 
 * 改进：用map的特性，将数组的value和下标 作为key-value保存在一个map，
 * 再去遍历，这种就是空间换时间，时间复杂度为O(n)
 */
public class TwoSum {

	public static void main(String[] args) {
		int []nums = {4,5,6,3,2,451,56,78,45};
		int target = 12;
		int []res = findTwoSum(nums,target);
		System.out.println("两个数的下标是："+Arrays.toString(res));
	}

	private static int[] findTwoSum(int[] nums, int target) {
		int []res = {-1,-1};
		Map<Integer, Integer> map = new HashMap<Integer, Integer>();
		for (int i = 0; i < nums.length; i++) {
			// 将数组的value和下标作为key-value保存在map中
			map.put(nums[i], i);
		}
		
		for (int i = 0; i < nums.length; i++) {
			int sec = target - nums[i];
			// 判断sec是否在map中，同时判断两个是否是同一个数，因为这里用的是&&，
			// 所以map.get(sec)不用考虑null值的问题
			if(map.containsKey(sec) && map.get(sec)!=i){
				res[0] = i;
				res[1] = map.get(sec);
			}
		}
		return res;
	}
}
